<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Coin God Pro Championship Edition - Refactored</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.85.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
        }
        #phaser-container {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="phaser-container"></div>

    <script>
        // ===== CONSTANTS AND CONFIGURATION =====
        const GAME_CONFIG = {
            WORLD_WIDTH: 1024,
            WORLD_HEIGHT: 768,
            FLOOR_Y: 680,
            GRAVITY: 400, // Back to original gravity
            PHYSICS_BOUNDS: {
                x: 0, y: -400, 
                width: 1024, height: 768 + 310 // Simple bounds like original
            }
        };

        const COLORS = {
            GOLD: 0xFFD700,
            ORANGE: 0xFF8C00,
            LIGHT_YELLOW: 0xFFFF99,
            PURPLE: 0xDA70D6,
            BROWN: 0x8B4513,
            MINT_GREEN: 0x98FB98,
            SOFT_PINK: 0xFFB6C1,
            ROYAL_BLUE: 0x4169E1
        };

        const DEFAULT_SAVE_DATA = {
            totalCoins: 200,
            maxCoins: 10,
            upgradeLevel: 0,
            basketLevel: 0,
            timerLevel: 0,
            bumperLevel: 0,
            gameTime: 10,
            baskets: [],
            bumpers: [],
            highscore: 0
        };

        // ===== UTILITY FUNCTIONS =====
        class GameUtils {
            static calculateUpgradeCost(basePrice, level, multiplier = 1.6) {
                return Math.floor(basePrice * Math.pow(multiplier, level));
            }

            static createParticleEffect(scene, x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const particle = scene.add.circle(x, y, 3, color);
                    const angle = (i / count) * Math.PI * 2;
                    const speed = Phaser.Math.Between(50, 150);
                    
                    scene.tweens.add({
                        targets: particle,
                        x: x + Math.cos(angle) * speed,
                        y: y + Math.sin(angle) * speed,
                        alpha: 0,
                        scaleX: 0,
                        scaleY: 0,
                        duration: 800,
                        ease: 'Power2',
                        onComplete: () => particle.destroy()
                    });
                }
            }

            static addButtonEffect(button, text, callback) {
                button.on('pointerover', () => button.setAlpha(0.8));
                button.on('pointerout', () => button.setAlpha(1));
                button.on('pointerdown', () => {
                    button.scene.tweens.add({
                        targets: [button, text],
                        scaleX: 0.95,
                        scaleY: 0.95,
                        duration: 100,
                        yoyo: true,
                        onComplete: callback
                    });
                });
            }
        }

        // ===== ASSET CREATION UTILITIES =====
        class AssetCreator {
            static createCoinFrames(scene) {
                for (let i = 1; i <= 7; i++) {
                    const coinCanvas = scene.add.graphics();
                    const radius = 20 + Math.sin(i * 0.5) * 5;
                    
                    coinCanvas.fillStyle(COLORS.GOLD);
                    coinCanvas.fillCircle(25, 25, radius);
                    coinCanvas.lineStyle(3, COLORS.ORANGE);
                    coinCanvas.strokeCircle(25, 25, radius);
                    coinCanvas.fillStyle(0xFFFFFF, 0.4);
                    coinCanvas.fillCircle(20, 20, 8);
                    
                    coinCanvas.generateTexture('coin_' + i.toString().padStart(2, '0'), 50, 50);
                    coinCanvas.destroy();
                }
            }

            static createVanishFrames(scene) {
                for (let i = 1; i <= 4; i++) {
                    const vanishCanvas = scene.add.graphics();
                    const alpha = 1 - (i - 1) / 3;
                    
                    vanishCanvas.fillStyle(COLORS.GOLD, alpha);
                    vanishCanvas.fillCircle(25, 25, 20);
                    vanishCanvas.lineStyle(3, COLORS.ORANGE, alpha);
                    vanishCanvas.strokeCircle(25, 25, 20);
                    
                    vanishCanvas.generateTexture('vanish_' + i, 50, 50);
                    vanishCanvas.destroy();
                }
            }

            static createBackground(scene) {
                const bgCanvas = scene.add.graphics();
                bgCanvas.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xE6E6FA, 0xE6E6FA);
                bgCanvas.fillRect(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
                bgCanvas.generateTexture('background', GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
                bgCanvas.destroy();
            }

            static createBasket(scene) {
                const basketCanvas = scene.add.graphics();
                basketCanvas.fillStyle(COLORS.BROWN);
                basketCanvas.beginPath();
                basketCanvas.arc(40, 35, 35, 0, Math.PI, false);
                basketCanvas.fillPath();
                basketCanvas.lineStyle(4, 0x654321);
                basketCanvas.beginPath();
                basketCanvas.arc(40, 35, 35, 0, Math.PI, false);
                basketCanvas.strokePath();
                basketCanvas.generateTexture('basket', 80, 50);
                basketCanvas.destroy();
            }

            static createBumper(scene) {
                const bumperCanvas = scene.add.graphics();
                bumperCanvas.fillStyle(COLORS.PURPLE);
                bumperCanvas.fillCircle(25, 25, 20);
                bumperCanvas.lineStyle(4, 0x9370DB);
                bumperCanvas.strokeCircle(25, 25, 20);
                bumperCanvas.fillStyle(0xFFFFFF, 0.6);
                bumperCanvas.fillCircle(18, 18, 8);
                bumperCanvas.generateTexture('bumper', 50, 50);
                bumperCanvas.destroy();
            }

            static createBigCoin(scene) {
                const bigCoinCanvas = scene.add.graphics();
                bigCoinCanvas.fillStyle(COLORS.LIGHT_YELLOW);
                bigCoinCanvas.fillCircle(35, 35, 30);
                bigCoinCanvas.lineStyle(5, COLORS.GOLD);
                bigCoinCanvas.strokeCircle(35, 35, 30);
                bigCoinCanvas.fillStyle(0xFFFFFF, 0.6);
                bigCoinCanvas.fillCircle(25, 25, 12);
                bigCoinCanvas.fillStyle(0xFFFFFF, 0.3);
                bigCoinCanvas.fillCircle(45, 45, 8);
                bigCoinCanvas.generateTexture('bigcoin', 70, 70);
                bigCoinCanvas.destroy();
            }

            static createFloor(scene) {
                const floorCanvas = scene.add.graphics();
                floorCanvas.fillStyle(0xF5DEB3);
                floorCanvas.fillRect(0, 0, GAME_CONFIG.WORLD_WIDTH, 70);
                floorCanvas.lineStyle(2, 0xDEB887);
                for (let i = 0; i < 15; i++) {
                    const y = 10 + (i * 4);
                    floorCanvas.lineBetween(0, y, GAME_CONFIG.WORLD_WIDTH, y);
                }
                floorCanvas.generateTexture('floor', GAME_CONFIG.WORLD_WIDTH, 70);
                floorCanvas.destroy();
            }
        }

        // ===== POSITION MANAGEMENT =====
        class PositionManager {
            static findBasketPosition(currentBaskets) {
                const basketRadius = 40;
                const minDistance = basketRadius * 2.2;
                const margin = 100;
                
                for (let attempts = 0; attempts < 100; attempts++) {
                    const x = Phaser.Math.Between(margin, GAME_CONFIG.WORLD_WIDTH - margin);
                    const y = 660;
                    
                    if (this.isValidPosition(x, y, currentBaskets, minDistance)) {
                        return { x, y };
                    }
                }
                return null;
            }

            static findBumperPosition(currentBumpers, currentBaskets) {
                const bumperRadius = 25;
                const minDistance = bumperRadius * 2.5;
                const margin = 100;
                
                for (let attempts = 0; attempts < 100; attempts++) {
                    const x = Phaser.Math.Between(margin, GAME_CONFIG.WORLD_WIDTH - margin);
                    const y = Phaser.Math.Between(300, 610);
                    
                    const validFromBumpers = this.isValidPosition(x, y, currentBumpers, minDistance);
                    const validFromBaskets = this.isValidPosition(x, y, currentBaskets, 80);
                    
                    if (validFromBumpers && validFromBaskets) {
                        return { x, y };
                    }
                }
                return null;
            }

            static isValidPosition(x, y, existingPositions, minDistance) {
                for (let pos of existingPositions) {
                    const distance = Phaser.Math.Distance.Between(x, y, pos.x, pos.y);
                    if (distance < minDistance) return false;
                }
                return true;
            }
        }

        // ===== MAIN SCENES =====
        class Boot extends Phaser.Scene {
            constructor() {
                super('Boot');
            }
            
            create() {
                // Initialize save data if not present
                Object.keys(DEFAULT_SAVE_DATA).forEach(key => {
                    if (!this.registry.has(key)) {
                        this.registry.set(key, DEFAULT_SAVE_DATA[key]);
                    }
                });
                
                this.scene.start('Preloader');
            }
        }

        class Preloader extends Phaser.Scene {
            constructor() {
                super("Preloader");
            }

            init() {
                this.createLoadingScreen();
            }

            createLoadingScreen() {
                this.add.rectangle(512, 384, 1024, 768, 0x028af8);
                this.add.text(512, 384, 'Loading...', {
                    fontFamily: 'Arial Black',
                    fontSize: 64,
                    color: '#ffffff'
                }).setOrigin(0.5);

                const progressBar = this.add.rectangle(512, 450, 468, 32);
                progressBar.setStrokeStyle(2, 0xffffff);
                const bar = this.add.rectangle(512-230, 450, 4, 28, 0xffffff);

                this.load.on("progress", (progress) => {
                    bar.width = 4 + (460 * progress);
                });
            }

            preload() {
                // Create all game assets
                AssetCreator.createCoinFrames(this);
                AssetCreator.createVanishFrames(this);
                AssetCreator.createBackground(this);
                AssetCreator.createBasket(this);
                AssetCreator.createBumper(this);
                AssetCreator.createBigCoin(this);
                AssetCreator.createFloor(this);
            }

            create() {
                this.createAnimations();
                this.transitionToMainMenu();
            }

            createAnimations() {
                this.anims.create({
                    key: "rotate",
                    frames: Array.from({length: 7}, (_, i) => ({ key: `coin_${(i+1).toString().padStart(2, '0')}` })),
                    frameRate: 16,
                    repeat: -1
                });

                this.anims.create({
                    key: "vanish",
                    frames: Array.from({length: 4}, (_, i) => ({ key: `vanish_${i+1}` })),
                    frameRate: 10
                });
            }

            transitionToMainMenu() {
                this.scene.transition({
                    target: 'MainMenu',
                    duration: 1000,
                    moveBelow: true,
                    onUpdate: (progress) => {
                        this.cameras.main.setAlpha(1 - progress);
                    }
                });
            }
        }

        class MainMenu extends Phaser.Scene {
            constructor() {
                super('MainMenu');
            }

            create() {
                this.setupBackground();
                this.createUI();
                this.setupInputHandlers();
            }

            setupBackground() {
                this.add.image(512, 384, 'background');
            }

            createUI() {
                const totalCoins = this.registry.get('totalCoins');
                const highscore = this.registry.get('highscore');
                
                const textStyle = {
                    fontFamily: 'Arial Black',
                    fontSize: 38,
                    color: '#6B4E71',
                    stroke: '#FFFFFF',
                    strokeThickness: 4
                };

                // Stats display
                const totalCoinsText = this.add.text(32, 32, `Total Coins: ${totalCoins}`, textStyle);
                const bestRoundText = this.add.text(32, 80, `Best Round: ${highscore}`, textStyle);
                
                this.addFloatingAnimation([totalCoinsText, bestRoundText]);

                // Instructions
                const instructions = [
                    "SUPER COIN GOD PRO",
                    "CHAMPIONSHIP EDITION",
                    "",
                    "How many coins can you",
                    "click in 10 seconds?",
                    "",
                    "Your coins NEVER reset!",
                    "",
                    "Click anywhere to Start!"
                ];

                const instructionText = this.add.text(512, 400, instructions, {
                    fontFamily: 'Arial Black',
                    fontSize: 28,
                    color: '#6B4E71',
                    stroke: '#FFFFFF',
                    strokeThickness: 3,
                    align: 'center'
                }).setOrigin(0.5);

                this.addPulseAnimation(instructionText);

                // Buttons - evenly spaced across the screen
                this.createButton(256, 650, 'PLAY', 0xFF6347, () => this.scene.start('ClickerGame'));
                this.createButton(512, 650, 'SHOP', COLORS.MINT_GREEN, () => this.scene.start('Shop'));
                this.createButton(768, 650, 'SETTINGS', COLORS.SOFT_PINK, () => this.scene.start('Settings'));
            }

            createButton(x, y, text, color, callback) {
                const buttonBg = this.add.graphics();
                buttonBg.fillStyle(color);
                buttonBg.fillRoundedRect(x-100, y-30, 200, 60, 15);
                buttonBg.lineStyle(4, color - 0x101010);
                buttonBg.strokeRoundedRect(x-100, y-30, 200, 60, 15);
                buttonBg.setInteractive(new Phaser.Geom.Rectangle(x-100, y-30, 200, 60), Phaser.Geom.Rectangle.Contains);

                
                const buttonText = this.add.text(x, y, text, {
                    fontFamily: 'Arial Black',
                    fontSize: 28,
                    color: '#4A5D4A'
                }).setOrigin(0.5);

                GameUtils.addButtonEffect(buttonBg, buttonText, callback);
            }

            addFloatingAnimation(targets) {
                this.tweens.add({
                    targets: targets,
                    y: '+=3',
                    duration: 2000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            addPulseAnimation(target) {
                this.tweens.add({
                    targets: target,
                    scaleX: 1.02,
                    scaleY: 1.02,
                    duration: 3000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            setupInputHandlers() {
                this.input.on('pointerdown', (pointer, currentlyOver) => {
                    if (currentlyOver.length === 0) {
                        this.scene.start('ClickerGame');
                    }
                });
            }
        }

        class Settings extends Phaser.Scene {
            constructor() {
                super('Settings');
            }

            create() {
                this.add.image(512, 384, 'background');
                
                this.add.text(512, 200, 'SETTINGS', {
                    fontFamily: 'Arial Black',
                    fontSize: 64,
                    color: '#FFD700',
                    stroke: '#000000',
                    strokeThickness: 8
                }).setOrigin(0.5);

                this.createResetButton();
                this.createBackButton();
            }

            createResetButton() {
                const resetButtonBg = this.add.graphics();
                resetButtonBg.fillStyle(0xCC0000);
                resetButtonBg.fillRoundedRect(362, 320, 300, 80, 10);
                resetButtonBg.lineStyle(4, 0xFF0000);
                resetButtonBg.strokeRoundedRect(362, 320, 300, 80, 10);
                resetButtonBg.setInteractive(new Phaser.Geom.Rectangle(362, 320, 300, 80), Phaser.Geom.Rectangle.Contains);

                this.add.text(512, 360, 'RESET EVERYTHING', {
                    fontFamily: 'Arial Black',
                    fontSize: 24,
                    color: '#ffffff'
                }).setOrigin(0.5);

                this.add.text(512, 450, 'Warning: This will reset all your progress!', {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    color: '#ffcccc'
                }).setOrigin(0.5);

                resetButtonBg.on('pointerdown', () => this.resetGame());
            }

            createBackButton() {
                const backButtonBg = this.add.graphics();
                backButtonBg.fillStyle(COLORS.ROYAL_BLUE);
                backButtonBg.fillRoundedRect(412, 550, 200, 60, 10);
                backButtonBg.lineStyle(4, 0x6495ED);
                backButtonBg.strokeRoundedRect(412, 550, 200, 60, 10);
                backButtonBg.setInteractive(new Phaser.Geom.Rectangle(412, 550, 200, 60), Phaser.Geom.Rectangle.Contains);

                this.add.text(512, 580, 'BACK', {
                    fontFamily: 'Arial Black',
                    fontSize: 28,
                    color: '#ffffff'
                }).setOrigin(0.5);

                backButtonBg.on('pointerdown', () => this.scene.start('MainMenu'));
            }

            resetGame() {
                Object.keys(DEFAULT_SAVE_DATA).forEach(key => {
                    this.registry.set(key, DEFAULT_SAVE_DATA[key]);
                });
                this.scene.start('MainMenu');
            }
        }

        class Shop extends Phaser.Scene {
            constructor() {
                super('Shop');
            }

            create() {
                this.setupBackground();
                this.createHeader();
                this.createUpgradeButtons();
                this.createNavigationButtons();
            }

            setupBackground() {
                this.add.image(512, 384, 'background');
            }

            createHeader() {
                const totalCoins = this.registry.get('totalCoins');
                const maxCoins = this.registry.get('maxCoins');
                const gameTime = this.registry.get('gameTime');
                
                this.add.text(512, 60, 'COIN SHOP', {
                    fontFamily: 'Arial Black',
                    fontSize: 48,
                    color: '#FFD700',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);

                this.add.text(512, 120, `Your Coins: ${totalCoins}`, {
                    fontFamily: 'Arial Black',
                    fontSize: 28,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setOrigin(0.5);

                this.add.text(512, 160, `Max Coins: ${maxCoins} | Game Time: ${gameTime}s`, {
                    fontFamily: 'Arial Black',
                    fontSize: 28,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setOrigin(0.5);
            }

            createUpgradeButtons() {
                const upgrades = this.getUpgradeData();
                
                upgrades.forEach((upgrade, index) => {
                    const x = 210 + (index % 2) * 604;
                    const y = 260 + Math.floor(index / 2) * 110;
                    this.createUpgradeButton(x, y, upgrade);
                });
            }

            getUpgradeData() {
                const totalCoins = this.registry.get('totalCoins');
                const upgradeLevel = this.registry.get('upgradeLevel');
                const timerLevel = this.registry.get('timerLevel');
                const basketLevel = this.registry.get('basketLevel');
                const bumperLevel = this.registry.get('bumperLevel');

                return [
                    {
                        name: 'Max Coins +1',
                        cost: GameUtils.calculateUpgradeCost(10, upgradeLevel, 1.6),
                        canAfford: totalCoins >= GameUtils.calculateUpgradeCost(10, upgradeLevel, 1.6),
                        canPurchase: true,
                        color: COLORS.MINT_GREEN,
                        action: () => this.buyCoinUpgrade()
                    },
                    {
                        name: 'Game Time +2s',
                        cost: GameUtils.calculateUpgradeCost(25, timerLevel, 1.8),
                        canAfford: totalCoins >= GameUtils.calculateUpgradeCost(25, timerLevel, 1.8),
                        canPurchase: true,
                        color: 0x87CEEB,
                        action: () => this.buyTimerUpgrade()
                    },
                    {
                        name: 'Buy Basket',
                        cost: GameUtils.calculateUpgradeCost(50, basketLevel, 1.7),
                        canAfford: totalCoins >= GameUtils.calculateUpgradeCost(50, basketLevel, 1.7),
                        canPurchase: PositionManager.findBasketPosition(this.registry.get('baskets')) !== null,
                        color: COLORS.BROWN,
                        action: () => this.buyBasket()
                    },
                    {
                        name: 'Buy Bumper',
                        cost: GameUtils.calculateUpgradeCost(25, bumperLevel, 1.7),
                        canAfford: totalCoins >= GameUtils.calculateUpgradeCost(25, bumperLevel, 1.7),
                        canPurchase: PositionManager.findBumperPosition(this.registry.get('bumpers'), this.registry.get('baskets')) !== null,
                        color: COLORS.PURPLE,
                        action: () => this.buyBumper()
                    }
                ];
            }

            createUpgradeButton(x, y, upgrade) {
                const available = upgrade.canAfford && upgrade.canPurchase;
                const color = available ? upgrade.color : 0x8B0000;
                
                const button = this.add.graphics();
                button.fillStyle(color);
                button.fillRoundedRect(x-140, y-40, 280, 80, 10);
                button.lineStyle(4, color - 0x101010);
                button.strokeRoundedRect(x-140, y-40, 280, 80, 10);
                
                let buttonText = `${upgrade.name}\nCost: ${upgrade.cost}`;
                if (!upgrade.canPurchase) buttonText += ' (No space!)';
                else if (!upgrade.canAfford) buttonText += ' (Need more!)';
                
                this.add.text(x, y, buttonText, {
                    fontFamily: 'Arial Black',
                    fontSize: 18,
                    color: '#ffffff',
                    align: 'center'
                }).setOrigin(0.5);

                if (available) {
                    button.setInteractive(new Phaser.Geom.Rectangle(x-140, y-40, 280, 80), Phaser.Geom.Rectangle.Contains);
                    button.on('pointerdown', upgrade.action);
                }
            }

            createNavigationButtons() {
                this.createNavButton(230, 670, 'BACK', () => this.scene.start('MainMenu'));
                this.createNavButton(794, 670, 'PLAY', () => this.scene.start('ClickerGame'));
            }

            createNavButton(x, y, text, callback) {
                const button = this.add.graphics();
                button.fillStyle(text === 'BACK' ? COLORS.ROYAL_BLUE : 0xFF6347);
                button.fillRoundedRect(x-60, y-20, 120, 40, 6);
                button.setInteractive(new Phaser.Geom.Rectangle(x-60, y-20, 120, 40), Phaser.Geom.Rectangle.Contains);

                const buttonText = this.add.text(x, y, text, {
                    fontFamily: 'Arial Black',
                    fontSize: 20,
                    color: '#ffffff'
                }).setOrigin(0.5);

                button.on('pointerdown', callback);
            }

            buyCoinUpgrade() {
                const cost = GameUtils.calculateUpgradeCost(10, this.registry.get('upgradeLevel'), 1.6);
                if (this.registry.get('totalCoins') >= cost) {
                    this.registry.set('totalCoins', this.registry.get('totalCoins') - cost);
                    this.registry.set('upgradeLevel', this.registry.get('upgradeLevel') + 1);
                    this.registry.set('maxCoins', this.registry.get('maxCoins') + 1);
                    this.scene.restart();
                }
            }

            buyTimerUpgrade() {
                const cost = GameUtils.calculateUpgradeCost(25, this.registry.get('timerLevel'), 1.8);
                if (this.registry.get('totalCoins') >= cost) {
                    this.registry.set('totalCoins', this.registry.get('totalCoins') - cost);
                    this.registry.set('timerLevel', this.registry.get('timerLevel') + 1);
                    this.registry.set('gameTime', this.registry.get('gameTime') + 2);
                    this.scene.restart();
                }
            }

            buyBasket() {
                const cost = GameUtils.calculateUpgradeCost(50, this.registry.get('basketLevel'), 1.7);
                const newPosition = PositionManager.findBasketPosition(this.registry.get('baskets'));
                
                if (this.registry.get('totalCoins') >= cost && newPosition) {
                    this.registry.set('totalCoins', this.registry.get('totalCoins') - cost);
                    this.registry.set('basketLevel', this.registry.get('basketLevel') + 1);
                    
                    const baskets = this.registry.get('baskets');
                    baskets.push(newPosition);
                    this.registry.set('baskets', baskets);
                    this.scene.restart();
                }
            }

            buyBumper() {
                const cost = GameUtils.calculateUpgradeCost(25, this.registry.get('bumperLevel'), 1.7);
                const newPosition = PositionManager.findBumperPosition(this.registry.get('bumpers'), this.registry.get('baskets'));
                
                if (this.registry.get('totalCoins') >= cost && newPosition) {
                    this.registry.set('totalCoins', this.registry.get('totalCoins') - cost);
                    this.registry.set('bumperLevel', this.registry.get('bumperLevel') + 1);
                    
                    const bumpers = this.registry.get('bumpers');
                    bumpers.push(newPosition);
                    this.registry.set('bumpers', bumpers);
                    this.scene.restart();
                }
            }
        }

        // ===== COIN CLASS FOR BETTER MANAGEMENT =====
        class Coin {
            constructor(scene, x, y, value = 1, isBig = false) {
                this.scene = scene;
                this.value = value;
                this.isBig = isBig;
                this.isBeingCollected = false;
                this.bumperCooldown = 0; // Prevent multiple bumper hits
                this.lastBumperHit = null; // Track which bumper was last hit
                
                // Create sprite with physics - SIMPLIFIED LIKE ORIGINAL
                this.sprite = scene.physics.add.sprite(x, y, isBig ? 'bigcoin' : 'coin_01');
                if (!isBig) this.sprite.play('rotate');
                
                // Physics setup - KEEP IT SIMPLE LIKE THE ORIGINAL
                this.sprite.setVelocityX(Phaser.Math.Between(-400, 400)); // Only horizontal velocity like original
                this.sprite.setCollideWorldBounds(true);
                this.sprite.setBounce(0.9); // Simple bounce
                this.sprite.setInteractive();
                
                // Create value display text
                this.valueText = scene.add.text(x, y, value.toString(), {
                    fontFamily: 'Arial Black',
                    fontSize: isBig ? 20 : 16,
                    color: '#000000',
                    stroke: '#FFFFFF',
                    strokeThickness: isBig ? 3 : 2
                }).setOrigin(0.5).setDepth(10);
                
                // Add special effects for big coins
                if (isBig) {
                    scene.tweens.add({
                        targets: this.sprite,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 500,
                        yoyo: true,
                        repeat: -1
                    });
                }
                
                // Particle effect on spawn
                GameUtils.createParticleEffect(scene, x, y, COLORS.GOLD, 5);
            }

            update() {
                // Decrease bumper cooldown over time
                if (this.bumperCooldown > 0) {
                    this.bumperCooldown -= 1;
                }
            }

            updateValueText() {
                if (this.valueText && this.sprite) {
                    this.valueText.x = this.sprite.x;
                    this.valueText.y = this.sprite.y;
                    this.valueText.setText(this.value.toString());
                }
            }

            canHitBumper(bumper) {
                // Prevent hitting the same bumper repeatedly or hitting any bumper during cooldown
                return this.bumperCooldown <= 0 && this.lastBumperHit !== bumper;
            }

            hitBumper(bumper) {
                // Apply impulse force to push coin away from bumper, but preserve some existing velocity
                const angle = Phaser.Math.Angle.Between(bumper.x, bumper.y, this.sprite.x, this.sprite.y);
                const force = 200; // Reduced force to not completely override physics
                
                // Add to existing velocity instead of replacing it
                const currentVelX = this.sprite.body.velocity.x;
                const currentVelY = this.sprite.body.velocity.y;
                
                this.sprite.setVelocity(
                    currentVelX + Math.cos(angle) * force,
                    currentVelY + Math.sin(angle) * force
                );
                
                // Set cooldown and track last bumper hit
                this.bumperCooldown = 30; // Reduced cooldown to 0.5 seconds
                this.lastBumperHit = bumper;
            }

            doubleValue() {
                this.value *= 2;
                this.sprite.setTint(COLORS.LIGHT_YELLOW);
                if (this.valueText) {
                    this.valueText.setText(this.value.toString());
                    this.valueText.setColor('#FF0000');
                }
            }

            destroy() {
                if (this.valueText) {
                    this.valueText.destroy();
                    this.valueText = null;
                }
                if (this.sprite) {
                    this.sprite.destroy();
                    this.sprite = null;
                }
            }

            collect() {
                if (this.isBeingCollected) return false;
                
                this.isBeingCollected = true;
                this.sprite.disableInteractive();
                this.sprite.setVelocity(0, 0);
                this.sprite.setAngularVelocity(0);
                
                // Visual effects
                this.scene.cameras.main.shake(50, 0.005);
                GameUtils.createParticleEffect(this.scene, this.sprite.x, this.sprite.y, COLORS.GOLD, 8);
                
                if (!this.isBig) {
                    this.sprite.play('vanish');
                    this.sprite.once('animationcomplete-vanish', () => this.destroy());
                } else {
                    // Special big coin destruction
                    this.scene.tweens.add({
                        targets: this.sprite,
                        scaleX: 2,
                        scaleY: 2,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => this.destroy()
                    });
                }
                
                return true;
            }

            collectInBasket(basket) {
                if (this.isBeingCollected) return false;
                
                this.isBeingCollected = true;
                this.sprite.disableInteractive();
                this.sprite.setVelocity(0, 0);
                
                // Animate to basket
                this.scene.tweens.add({
                    targets: this.sprite,
                    x: basket.x,
                    y: basket.y - 10,
                    scaleX: 0.5,
                    scaleY: 0.5,
                    alpha: 0,
                    duration: 300,
                    onComplete: () => this.destroy()
                });
                
                // Basket animation
                this.scene.tweens.add({
                    targets: basket,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 100,
                    yoyo: true
                });
                
                return true;
            }
        }

        // ===== GAME SCENE WITH IMPROVED ORGANIZATION =====
        class ClickerGame extends Phaser.Scene {
            constructor() {
                super('ClickerGame');
            }

            init() {
                this.initializeGameState();
                this.initializeArrays();
            }

            initializeGameState() {
                this.roundScore = 0;
                this.totalCoins = this.registry.get('totalCoins');
                this.maxCoins = this.registry.get('maxCoins');
                this.gameTime = this.registry.get('gameTime');
                this.bigCoinSpawned = false;
            }

            initializeArrays() {
                this.coinObjects = [];
                this.basketSprites = [];
                this.bumperSprites = [];
            }

            create() {
                this.setupWorld();
                this.createUI();
                this.createGameObjects();
                this.setupPhysics();
                this.setupInput();
                this.spawnInitialCoins();
                this.startTimer();
            }

            setupWorld() {
                this.add.image(512, 384, 'background');
                this.add.image(512, GAME_CONFIG.FLOOR_Y, 'floor').setOrigin(0.5, 0);
                
                // SIMPLE physics bounds like the original - this is the key!
                this.physics.world.setBounds(
                    GAME_CONFIG.PHYSICS_BOUNDS.x,
                    GAME_CONFIG.PHYSICS_BOUNDS.y,
                    GAME_CONFIG.PHYSICS_BOUNDS.width,
                    GAME_CONFIG.PHYSICS_BOUNDS.height
                );
                
                // NO SEPARATE FLOOR COLLIDER - let world bounds handle it!
                // The original doesn't use a separate floor collider
            }

            createUI() {
                const textStyle = {
                    fontFamily: 'Arial Black',
                    fontSize: 38,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 8
                };

                this.roundScoreText = this.add.text(32, 32, `Round: ${this.roundScore}`, textStyle).setDepth(1);
                this.totalCoinsText = this.add.text(32, 80, `Total: ${this.totalCoins}`, textStyle).setDepth(1);
                this.maxCoinsText = this.add.text(32, 128, `Max: ${this.maxCoins}`, {
                    fontFamily: 'Arial Black',
                    fontSize: 24,
                    color: '#FFD700',
                    stroke: '#000000',
                    strokeThickness: 8
                }).setDepth(1);
                this.timeText = this.add.text(1024 - 32, 32, `Time: ${this.gameTime}`, textStyle).setOrigin(1, 0).setDepth(1);
            }

            createGameObjects() {
                this.createBaskets();
                this.createBumpers();
            }

            createBaskets() {
                const basketPositions = this.registry.get('baskets');
                basketPositions.forEach(pos => {
                    const basket = this.add.image(pos.x, pos.y, 'basket');
                    basket.setInteractive({ draggable: true });
                    this.physics.add.existing(basket, true);
                    basket.body.setSize(70, 40);
                    this.basketSprites.push(basket);
                    
                    this.setupBasketDragging(basket, pos);
                    basket.on('pointerdown', () => this.clickBasket(basket));
                });
            }

            setupBasketDragging(basket, originalPos) {
                basket.on('drag', (pointer, dragX, dragY) => {
                    basket.x = dragX;
                    basket.y = originalPos.y; // Keep Y fixed
                    basket.body.x = dragX - 35;
                    basket.body.y = originalPos.y - 20;
                    
                    // Update registry
                    const basketPositions = this.registry.get('baskets');
                    const index = this.basketSprites.indexOf(basket);
                    if (index !== -1 && basketPositions[index]) {
                        basketPositions[index].x = dragX;
                        this.registry.set('baskets', basketPositions);
                    }
                });
            }

            createBumpers() {
                const bumperPositions = this.registry.get('bumpers');
                bumperPositions.forEach(pos => {
                    const bumper = this.add.image(pos.x, pos.y, 'bumper');
                    bumper.setInteractive({ draggable: true });
                    this.physics.add.existing(bumper, true);
                    bumper.body.setSize(40, 40);
                    bumper.body.setCircle(20);
                    this.bumperSprites.push(bumper);
                    
                    this.setupBumperDragging(bumper);
                    this.addBumperAnimation(bumper);
                });
            }

            setupBumperDragging(bumper) {
                bumper.on('drag', (pointer, dragX, dragY) => {
                    bumper.x = dragX;
                    bumper.y = dragY;
                    bumper.body.x = dragX - 20;
                    bumper.body.y = dragY - 20;
                    
                    // Update registry
                    const bumperPositions = this.registry.get('bumpers');
                    const index = this.bumperSprites.indexOf(bumper);
                    if (index !== -1 && bumperPositions[index]) {
                        bumperPositions[index].x = dragX;
                        bumperPositions[index].y = dragY;
                        this.registry.set('bumpers', bumperPositions);
                    }
                });
            }

            addBumperAnimation(bumper) {
                this.tweens.add({
                    targets: bumper,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            setupPhysics() {
                // Don't set up collision groups - handle collisions individually per coin
                // when they are created, just like the original example
            }

            setupCollisionForCoin(coin) {
                // Set up collisions for this specific coin with existing baskets and bumpers
                if (this.basketSprites.length > 0) {
                    this.basketSprites.forEach(basket => {
                        this.physics.add.overlap(coin.sprite, basket, (coinSprite, basket) => {
                            this.handleBasketCollection(coinSprite, basket);
                        });
                    });
                }
                
                if (this.bumperSprites.length > 0) {
                    this.bumperSprites.forEach(bumper => {
                        this.physics.add.collider(coin.sprite, bumper, (coinSprite, bumper) => {
                            this.handleBumperCollision(coinSprite, bumper);
                        });
                    });
                }
            }

            setupInput() {
                this.input.on('gameobjectdown', (pointer, gameObject) => {
                    if (gameObject.texture) {
                        if (gameObject.texture.key.startsWith('coin_')) {
                            this.handleCoinClick(gameObject);
                        } else if (gameObject.texture.key === 'bigcoin') {
                            this.handleCoinClick(gameObject);
                        }
                    }
                });
            }

            spawnInitialCoins() {
                for (let i = 0; i < this.maxCoins; i++) {
                    this.spawnCoin();
                }
            }

            startTimer() {
                this.timer = this.time.addEvent({
                    delay: this.gameTime * 1000,
                    callback: () => this.gameOver()
                });
            }

            spawnCoin(isBig = false) {
                const x = Phaser.Math.Between(128, 896);
                const y = Phaser.Math.Between(0, -400);
                const value = isBig ? 10 : 1;
                
                const coin = new Coin(this, x, y, value, isBig);
                this.coinObjects.push(coin);
                
                // Set up collisions for this coin with existing baskets and bumpers
                this.setupCollisionForCoin(coin);
            }

            handleCoinClick(sprite) {
                // Find the coin object associated with this sprite
                const coinObj = this.coinObjects.find(c => c.sprite === sprite);
                if (!coinObj || !coinObj.collect()) return;
                
                this.addScore(coinObj.value);
                this.showBonusText(sprite.x, sprite.y, coinObj.value);
                this.updateScoreDisplay();
                this.removeCoinFromArray(coinObj);
                
                // Spawn replacement if needed
                if (this.coinObjects.length < this.maxCoins) {
                    this.spawnCoin();
                }
            }

            handleBasketCollection(coinSprite, basket) {
                const coinObj = this.coinObjects.find(c => c.sprite === coinSprite);
                if (!coinObj || !coinObj.collectInBasket(basket)) return;
                
                const bonusValue = coinObj.value + 1;
                this.addScore(bonusValue);
                this.showBasketBonusText(basket.x, basket.y, bonusValue);
                this.updateScoreDisplay();
                this.removeCoinFromArray(coinObj);
                
                // Spawn replacement if needed
                if (this.coinObjects.length < this.maxCoins) {
                    this.spawnCoin();
                }
            }

            handleBumperCollision(coinSprite, bumper) {
                const coinObj = this.coinObjects.find(c => c.sprite === coinSprite);
                if (!coinObj || !coinObj.canHitBumper(bumper)) return;
                
                // Apply bumper effects
                coinObj.hitBumper(bumper);
                coinObj.doubleValue();
                this.showBumperEffect(bumper);
            }

            clickBasket(basket) {
                const bonusCoins = 5;
                this.addScore(bonusCoins);
                this.showBasketBonusText(basket.x, basket.y - 30, bonusCoins);
                this.updateScoreDisplay();
                
                this.tweens.add({
                    targets: basket,
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 100,
                    yoyo: true
                });
            }

            addScore(points) {
                this.roundScore += points;
                this.totalCoins += points;
                this.registry.set('totalCoins', this.totalCoins);
            }

            updateScoreDisplay() {
                this.roundScoreText.setText(`Round: ${this.roundScore}`);
                this.totalCoinsText.setText(`Total: ${this.totalCoins}`);
                
                // Pulse animation
                this.tweens.add({
                    targets: [this.roundScoreText, this.totalCoinsText],
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 200,
                    yoyo: true,
                    ease: 'Back.easeOut'
                });
            }

            showBonusText(x, y, value) {
                const color = value > 1 ? '#FFFF99' : '#FFD700';
                const stroke = value > 1 ? '#DA70D6' : '#FF8C00';
                
                const bonusText = this.add.text(x, y - 30, `+${value}!`, {
                    fontFamily: 'Arial Black',
                    fontSize: value > 10 ? 36 : 24,
                    color: color,
                    stroke: stroke,
                    strokeThickness: value > 10 ? 4 : 2
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: bonusText,
                    y: y - (value > 10 ? 100 : 60),
                    scaleX: value > 10 ? 1.5 : 1,
                    scaleY: value > 10 ? 1.5 : 1,
                    alpha: 0,
                    duration: value > 10 ? 2000 : 1200,
                    onComplete: () => bonusText.destroy()
                });
            }

            showBasketBonusText(x, y, value) {
                const bonusText = this.add.text(x, y - 40, `+${value}!`, {
                    fontFamily: 'Arial Black',
                    fontSize: 20,
                    color: '#FFD700',
                    stroke: '#8B4513',
                    strokeThickness: 2
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: bonusText,
                    y: y - 70,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => bonusText.destroy()
                });
            }

            showBumperEffect(bumper) {
                // Visual feedback
                this.tweens.add({
                    targets: bumper,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 200,
                    yoyo: true,
                    ease: 'Back.easeOut'
                });
                
                // Particle effect
                GameUtils.createParticleEffect(this, bumper.x, bumper.y, COLORS.PURPLE, 6);
                
                // Show multiplier text
                const bonusText = this.add.text(bumper.x, bumper.y - 30, '2x!', {
                    fontFamily: 'Arial Black',
                    fontSize: 20,
                    color: '#DA70D6',
                    stroke: '#FFFFFF',
                    strokeThickness: 2
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: bonusText,
                    y: bumper.y - 60,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => bonusText.destroy()
                });
            }

            removeCoinFromArray(coinObj) {
                const index = this.coinObjects.indexOf(coinObj);
                if (index > -1) {
                    this.coinObjects.splice(index, 1);
                }
            }

            update() {
                if (!this.timer) return;
                
                this.timeText.setText(`Time: ${Math.ceil(this.timer.getRemainingSeconds())}`);
                
                // Update coin value text positions and cooldowns
                this.coinObjects.forEach(coin => {
                    coin.updateValueText();
                    coin.update(); // Update cooldowns
                });
                
                // Spawn big coin at 5 seconds if not already spawned
                if (!this.bigCoinSpawned && this.timer.getRemainingSeconds() <= 5) {
                    this.spawnCoin(true);
                    this.bigCoinSpawned = true;
                }
            }

            gameOver() {
                // Clean up all coins
                this.coinObjects.forEach(coin => {
                    coin.sprite.setVelocity(0, 0);
                    if (!coin.isBig) coin.sprite.play('vanish');
                    coin.destroy();
                });
                this.coinObjects = [];

                this.input.off('gameobjectdown');

                // Update high score
                const currentBest = this.registry.get('highscore');
                if (this.roundScore > currentBest) {
                    this.registry.set('highscore', this.roundScore);
                }

                this.time.delayedCall(2000, () => this.scene.start('GameOver'));
            }

            shutdown() {
                // Clean up when scene shuts down
                this.coinObjects = [];
                this.basketSprites = [];
                this.bumperSprites = [];
            }
        }

        class GameOver extends Phaser.Scene {
            constructor() {
                super('GameOver');
            }

            create() {
                const totalCoins = this.registry.get('totalCoins');
                const bestRound = this.registry.get('highscore');
                
                this.add.image(512, 384, 'background');

                const message = [
                    "Time's Up!",
                    "",
                    `Total Coins: ${totalCoins}`,
                    `Best Round: ${bestRound}`,
                    "",
                    "Click to Continue"
                ];

                this.add.text(512, 384, message, {
                    fontFamily: 'Arial Black',
                    fontSize: 36,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 8,
                    align: 'center'
                }).setOrigin(0.5);

                this.input.once('pointerdown', () => {
                    this.scene.start('MainMenu');
                });
            }
        }

        // ===== GAME CONFIGURATION =====
        const config = {
            type: Phaser.AUTO,
            width: GAME_CONFIG.WORLD_WIDTH,
            height: GAME_CONFIG.WORLD_HEIGHT,
            parent: "phaser-container",
            backgroundColor: "#028af8",
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: "arcade",
                arcade: {
                    gravity: { y: GAME_CONFIG.GRAVITY }
                }
            },
            scene: [
                Boot,
                Preloader,
                MainMenu,
                Settings,
                Shop,
                ClickerGame,
                GameOver
            ]
        };

        new Phaser.Game(config);
    </script>
</body>
</html>